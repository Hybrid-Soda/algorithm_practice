## 1. Dynamic Programming (동적 계획법)
동적 계획법은 복잡한 문제를 작은 하위 문제로 나누어 해결하는 방법으로, 각 하위 문제의 해결 결과를 저장하고 재사용함으로써 전체 문제를 해결 이 기법은 주로 최적화 문제에서 사용되며, 하위 문제들이 중복되는 경우에 효과적이다.

- 특징 :
메모이제이션(Memoization) 또는 테이블화(Tableization) 기법을 사용하여 하위 문제의 해답을 저장
중복 계산을 방지하여 실행 시간을 줄인다.

- 사용 사례 : 피보나치 수열, 최단 경로 찾기(벨만-포드, 플로이드-워셜 알고리즘), 배낭 문제(Knapsack Problem), 최장 공통 부분 수열(Longest Common Subsequence)


## 2. Divide and Conquer (분할 정복)
분할 정복 방법은 문제를 더 작은 하위 문제로 분할하고, 각각의 하위 문제를 독립적으로 해결한 다음, 이 해결책들을 결합하여 전체 문제의 해결책을 얻는다. 이 기법은 하위 문제들이 중복되지 않을 때 효과적이다.

- 특징 :
문제를 분할하여 각각을 해결하고, 해결된 부분들을 합쳐 전체 문제를 해결 /
재귀적 접근 방식 사용

- 사용 사례 : 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort), 이진 탐색(Binary Search), 행렬의 곱셈, 힙 정렬(Heap Sort)


## 3. Greedy Algorithm (탐욕 알고리즘)
탐욕 알고리즘은 매 선택에서 지금 당장 최적인 선택을 하는 방식으로, 전체에서의 최적해를 구하는 방법이다. 각 단계에서의 최선의 선택이 전체에서도 최선이라는 보장은 없지만, 많은 문제에서 효율적인 해결책을 제공함.

- 특징 :
매 순간 최적이라고 생각되는 선택을 함으로써 최종 결과를 도출 /
전역 최적화를 보장하지 않는 경우가 많다.

- 사용 사례 : 최소 신장 트리(Minimum Spanning Tree), 다익스트라 알고리즘(Dijkstra's Algorithm), 우선순위 큐, 할당 문제(예: 활동 선택 문제)


## 4. Backtracking (백트래킹)
백트래킹은 모든 가능한 경우의 수 중에서 해를 찾는 도중, 현재의 경로가 해결책으로 이어질 것 같지 않으면 이전 분기점으로 돌아가 다른 경로를 탐색하는 방법이다. 주로 결정 트리를 사용하는 문제에서 사용된다.

- 특징 :
가능한 모든 방법을 시도해보며 해답을 찾는다.
해답이 될 가능성이 없는 경로를 조기에 차단(Pruning)함으로써 탐색 공간을 줄인다. 이는 불필요한 탐색을 줄여 실행 시간을 개선하는 데 도움이 된다.

- 사용 사례 : N-Queen 문제, 스도쿠, 그래프 색칠 문제, 조합 문제(Combination Problems), 순열 문제(Permutation Problems)

## 적절한 알고리즘 선택
- 동적 계획법(Dynamic Programming) : 문제가 중복된 하위 문제들로 구성되어 있고, 이전에 계산한 하위 문제의 결과를 재사용할 수 있는 경우 사용한다. 최적화 문제나 카운팅 문제에서 유용하다.

- 분할 정복(Divide and Conquer) : 문제를 독립적인 하위 문제로 나눌 수 있고, 이 하위 문제들을 개별적으로 해결한 뒤 그 결과를 결합하여 전체 문제의 해를 구할 수 있는 경우에 적합하다. 분할 정복은 정렬, 이진 탐색, 고속 푸리에 변환(FFT) 등에 효과적이다.

- 탐욕 알고리즘(Greedy Algorithm) : 각 단계에서 지역적으로 최적인 선택을 하여 전역적으로도 최적의 해결책을 얻을 수 있는 문제에 적합하다. 하지만 모든 문제에 적용할 수 있는 것은 아니며, 탐욕 알고리즘이 적용 가능한지를 판단하는 것이 중요하다.

- 백트래킹(Backtracking) : 모든 가능한 해를 탐색해야 하지만, 탐색 과정에서 불필요한 부분을 조기에 제거할 수 있는 경우에 사용한다. 결정 트리를 사용하는 문제나 조합적 탐색 문제에서 유용하게 활용한다.